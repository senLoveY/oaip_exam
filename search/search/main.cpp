#include <iostream>

using namespace std;

// Линейный поиск: проходит по массиву по одному элементу, пока не найдет искомое значение или не достигнет конца массива.
int linear_search(int m[], int n, int l){
    // Добавляем искомое значение в конец массива для упрощения проверки условия выхода из цикла
    m[n] = l;
    int i = 0;
    // Проходим по массиву, пока не найдем искомое значение
    while(m[i] != l){
        i++;
    }
    // Если индекс искомого значения, равен номеру элемента, добавленного в массив, то возвращаем -1
    if(i == n)
        return -1;
        // Иначе возвращаем i, сигнализируя о наличии значения в массиве
    else
        return i;
}

// Бинарный поиск: предполагает, что массив отсортирован. Делит массив пополам и сравнивает искомое значение с элементом в середине.
// Если значение меньше, то поиск продолжается в левой половине, иначе - в правой.
int binary_search(int m[], int n, int l){
    int i=0, j=n-1, k;
    // Продолжаем поиск, пока левая граница не станет больше правой
    while(i < j)
    {
        // Находим средний элемент
        k = (i+j)/2;
        // Если искомое значение больше среднего элемента, то поиск продолжается в правой половине массива
        if(l > m[k]){
            i = k + 1;
        }
            // Иначе поиск продолжается в левой половине массива
        else{
            j = k;
        }
    }
    // Если нашли искомое значение, возвращаем его индекс
    if(m[i] == l)
        return i;
        // Иначе возвращаем -1, сигнализируя об отсутствии значения в массиве
    else
        return -1;
}

// Интерполяционный поиск: предполагает, что массив отсортирован. Использует интерполяцию для определения следующего элемента для проверки,
// что делает его более эффективным, чем бинарный поиск, если значения в массиве распределены равномерно.
int interpol_search(int m[], int n, int l){
    int i=0, j=n-1, k;
    // Продолжаем поиск, пока левая граница не станет больше правой
    while(i <= j) {
        // Если все элементы массива одинаковы, то проверяем, равен ли первый элемент искомому значению
        if (m[i] == m[j]) {
            if (m[i] == l)
                return i;
            else
                return -1;
        }
        // Вычисляем индекс следующего элемента для проверки с помощью интерполяции
        k = i + (j - i) * (l - m[i]) / (m[j] - m[i]);
        // Проверяем, не вышел ли индекс за границы массива
        if (k < i || k > j) {
            return -1;
        }
        // Если нашли искомое значение, возвращаем его индекс
        if (m[k] == l) return k;
            // Если искомое значение больше текущего элемента, то поиск продолжается в правой половине массива
        else {
            if (l > m[k]) {
                i = k + 1;
            }
                // Иначе поиск продолжается в левой половине массива
            else {
                j = k - 1;
            }

        }
    }
    return -1;
}



int main() {

    int n;
    cin>>n;
    int* m = new int[n + 1]; // Выделяем память под n+1 элементов(это по сути нужно только для усовершенствованного линейного поиска)

    for (int i = 0; i < n; ++i) {
        cin>>m[i];
    }

    int l;
    cin>>l;

    cout << "Линейный поиск: " << linear_search(m, n, l) << endl;
    cout << "Бинарный поиск: " << binary_search(m, n, l) << endl;
    cout << "Интерполяционный поиск: " << interpol_search(m, n, l) << endl;


    delete[] m;
    return 0;
}
